"use strict";(self.webpackChunknature_2_d_docs=self.webpackChunknature_2_d_docs||[]).push([[342],{3905:function(e,t,n){n.d(t,{Zo:function(){return s},kt:function(){return m}});var i=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,i,o=function(e,t){if(null==e)return{};var n,i,o={},a=Object.keys(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var d=i.createContext({}),p=function(e){var t=i.useContext(d),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},s=function(e){var t=p(e.components);return i.createElement(d.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},u=i.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,d=e.parentName,s=l(e,["components","mdxType","originalType","parentName"]),u=p(n),m=o,h=u["".concat(d,".").concat(m)]||u[m]||c[m]||a;return n?i.createElement(h,r(r({ref:t},s),{},{components:n})):i.createElement(h,r({ref:t},s))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,r=new Array(a);r[0]=u;var l={};for(var d in t)hasOwnProperty.call(t,d)&&(l[d]=t[d]);l.originalType=e,l.mdxType="string"==typeof e?e:o,r[1]=l;for(var p=2;p<a;p++)r[p]=n[p];return i.createElement.apply(null,r)}return i.createElement.apply(null,n)}u.displayName="MDXCreateElement"},1104:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return l},contentTitle:function(){return d},metadata:function(){return p},toc:function(){return s},default:function(){return u}});var i=n(7462),o=n(3366),a=(n(7294),n(3905)),r=["components"],l={sidebar_position:3},d="Point",p={unversionedId:"api/Point",id:"api/Point",isDocsHomePage:!1,title:"Point",description:"Points are what make the rigid bodies behave like real world entities. They are responsible for the movement of the RigidBodies and Constraints.",source:"@site/docs/api/Point.md",sourceDirName:"api",slug:"/api/Point",permalink:"/Nature2D/docs/api/Point",editUrl:"https://github.com/jaipack17/Nature2D/edit/master/docs/docs/api/Point.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"RigidBody",permalink:"/Nature2D/docs/api/RigidBody"},next:{title:"Constraint",permalink:"/Nature2D/docs/api/Constraint"}},s=[{value:"Types",id:"types",children:[],level:2},{value:"Functions",id:"functions",children:[{value:"<code>Point.new()</code>",id:"pointnew",children:[],level:3},{value:"<code>Point:ApplyForce()</code>",id:"pointapplyforce",children:[],level:3},{value:"<code>Point:Update()</code>",id:"pointupdate",children:[],level:3},{value:"<code>Point:KeepInCanvas()</code>",id:"pointkeepincanvas",children:[],level:3},{value:"<code>Point:Render()</code>",id:"pointrender",children:[],level:3},{value:"<code>Point:Destroy()</code>",id:"pointdestroy",children:[],level:3},{value:"<code>Point:SetRadius()</code>",id:"pointsetradius",children:[],level:3},{value:"<code>Point:Stroke()</code>",id:"pointstroke",children:[],level:3},{value:"<code>Point:Snap()</code>",id:"pointsnap",children:[],level:3},{value:"<code>Point:SetPosition()</code>",id:"pointsetposition",children:[],level:3},{value:"<code>Point:SetMaxForce()</code>",id:"pointsetmaxforce",children:[],level:3}],level:2},{value:"Fetch Methods",id:"fetch-methods",children:[{value:"<code>Point:Velocity()</code>",id:"pointvelocity",children:[],level:3},{value:"<code>Point:GetParent()</code>",id:"pointgetparent",children:[],level:3},{value:"<code>Point:GetNetForce()</code>",id:"pointgetnetforce",children:[],level:3}],level:2},{value:"Properties",id:"properties",children:[{value:"Visible <code>boolean</code>",id:"visible-boolean",children:[],level:3},{value:"Snap <code>boolean</code>",id:"snap-boolean",children:[],level:3},{value:"KeepInCanvas <code>boolean</code>",id:"keepincanvas-boolean",children:[],level:3},{value:"Radius <code>number</code>",id:"radius-number",children:[],level:3},{value:"Color <code>number</code>",id:"color-number",children:[],level:3}],level:2}],c={toc:s};function u(e){var t=e.components,n=(0,o.Z)(e,r);return(0,a.kt)("wrapper",(0,i.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"point"},"Point"),(0,a.kt)("p",null,"Points are what make the rigid bodies behave like real world entities. They are responsible for the movement of the RigidBodies and Constraints."),(0,a.kt)("div",{className:"admonition admonition-caution alert alert--warning"},(0,a.kt)("div",{parentName:"div",className:"admonition-heading"},(0,a.kt)("h5",{parentName:"div"},(0,a.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,a.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"16",height:"16",viewBox:"0 0 16 16"},(0,a.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"}))),(0,a.kt)("strong",{parentName:"h5"},"NOTE:"))),(0,a.kt)("div",{parentName:"div",className:"admonition-content"},(0,a.kt)("p",{parentName:"div"},"Points are handled by the Engine by default. Points are created for RigidBodies on creation. This class should only be used to create points for custom constraints and rigid bodies."),(0,a.kt)("p",{parentName:"div"},"Use ",(0,a.kt)("inlineCode",{parentName:"p"},"Engine:Create()")," to create custom points!"))),(0,a.kt)("h2",{id:"types"},"Types"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-lua"},"type EngineConfig = {\n    gravity: Vector2,\n    friction: number,\n    bounce: number\n}\n\ntype Canvas = {\n    topLeft: Vector2,\n    size: Vector2,\n    frame: Frame\n}\n\ntype PointConfig = {\n    snap: boolean, \n    selectable: boolean, \n    render: boolean,\n    keepInCanvas: boolean\n}\n")),(0,a.kt)("h2",{id:"functions"},"Functions"),(0,a.kt)("h3",{id:"pointnew"},(0,a.kt)("inlineCode",{parentName:"h3"},"Point.new()")),(0,a.kt)("p",null,"This method is used to initialize a new Point."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"parameters - ",(0,a.kt)("inlineCode",{parentName:"li"},"pos: Vector2, canvas: Canvas, engine: EngineConfig, config: PointConfig")),(0,a.kt)("li",{parentName:"ul"},"returns - ",(0,a.kt)("inlineCode",{parentName:"li"},"Point"))),(0,a.kt)("hr",null),(0,a.kt)("h3",{id:"pointapplyforce"},(0,a.kt)("inlineCode",{parentName:"h3"},"Point:ApplyForce()")),(0,a.kt)("p",null,"This method is used to apply a force to the Point. The time parameter can be passed in the function to apply the force for a certain time period."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"parameters - ",(0,a.kt)("inlineCode",{parentName:"li"},"force: Vector2, time: number | nil")),(0,a.kt)("li",{parentName:"ul"},"returns - ",(0,a.kt)("inlineCode",{parentName:"li"},"nil"))),(0,a.kt)("hr",null),(0,a.kt)("h3",{id:"pointupdate"},(0,a.kt)("inlineCode",{parentName:"h3"},"Point:Update()")),(0,a.kt)("div",{className:"admonition admonition-caution alert alert--warning"},(0,a.kt)("div",{parentName:"div",className:"admonition-heading"},(0,a.kt)("h5",{parentName:"div"},(0,a.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,a.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"16",height:"16",viewBox:"0 0 16 16"},(0,a.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"}))),"NOTE:")),(0,a.kt)("div",{parentName:"div",className:"admonition-content"},(0,a.kt)("p",{parentName:"div"},"This method is automatically handled by the engine!"))),(0,a.kt)("p",null,"This method is used to apply external forces like gravity and is responsible for moving the point."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"parameters - ",(0,a.kt)("inlineCode",{parentName:"li"},"dt: number")),(0,a.kt)("li",{parentName:"ul"},"returns - ",(0,a.kt)("inlineCode",{parentName:"li"},"nil"))),(0,a.kt)("hr",null),(0,a.kt)("h3",{id:"pointkeepincanvas"},(0,a.kt)("inlineCode",{parentName:"h3"},"Point:KeepInCanvas()")),(0,a.kt)("p",null,"This method is used to keep the point in the engine's canvas. Any point that goes past the canvas, is positioned correctly and the direction of its flipped is reversed accordingly. "),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"parameters - ",(0,a.kt)("inlineCode",{parentName:"li"},"none")),(0,a.kt)("li",{parentName:"ul"},"returns - ",(0,a.kt)("inlineCode",{parentName:"li"},"nil"))),(0,a.kt)("hr",null),(0,a.kt)("h3",{id:"pointrender"},(0,a.kt)("inlineCode",{parentName:"h3"},"Point:Render()")),(0,a.kt)("div",{className:"admonition admonition-caution alert alert--warning"},(0,a.kt)("div",{parentName:"div",className:"admonition-heading"},(0,a.kt)("h5",{parentName:"div"},(0,a.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,a.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"16",height:"16",viewBox:"0 0 16 16"},(0,a.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"}))),"NOTE:")),(0,a.kt)("div",{parentName:"div",className:"admonition-content"},(0,a.kt)("p",{parentName:"div"},"This method is automatically handled by the engine!"))),(0,a.kt)("p",null,"This method is used to update the position and appearance of the Point on screen."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"parameters - ",(0,a.kt)("inlineCode",{parentName:"li"},"none")),(0,a.kt)("li",{parentName:"ul"},"returns - ",(0,a.kt)("inlineCode",{parentName:"li"},"nil"))),(0,a.kt)("hr",null),(0,a.kt)("h3",{id:"pointdestroy"},(0,a.kt)("inlineCode",{parentName:"h3"},"Point:Destroy()")),(0,a.kt)("p",null,"Destroys the point's GuiObject, destroys the point's parent constraint (if any), and the point is no longer a part of the engine."),(0,a.kt)("hr",null),(0,a.kt)("h3",{id:"pointsetradius"},(0,a.kt)("inlineCode",{parentName:"h3"},"Point:SetRadius()")),(0,a.kt)("p",null,"This method is used to determine the radius of the point."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"parameters - ",(0,a.kt)("inlineCode",{parentName:"li"},"radius: number")),(0,a.kt)("li",{parentName:"ul"},"returns ",(0,a.kt)("inlineCode",{parentName:"li"},"nil"))),(0,a.kt)("hr",null),(0,a.kt)("h3",{id:"pointstroke"},(0,a.kt)("inlineCode",{parentName:"h3"},"Point:Stroke()")),(0,a.kt)("p",null,"This method is used to determine the color of the point on screen. By default this is set to (RED) Color3.new(1, 0, 0)."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"parameters - ",(0,a.kt)("inlineCode",{parentName:"li"},"color: Color3")),(0,a.kt)("li",{parentName:"ul"},"returns ",(0,a.kt)("inlineCode",{parentName:"li"},"nil"))),(0,a.kt)("hr",null),(0,a.kt)("h3",{id:"pointsnap"},(0,a.kt)("inlineCode",{parentName:"h3"},"Point:Snap()")),(0,a.kt)("p",null,"This method determines if the point remains anchored. If set to false, the point is unanchored."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"parameters - ",(0,a.kt)("inlineCode",{parentName:"li"},"snap: boolean")),(0,a.kt)("li",{parentName:"ul"},"returns ",(0,a.kt)("inlineCode",{parentName:"li"},"nil"))),(0,a.kt)("hr",null),(0,a.kt)("h3",{id:"pointsetposition"},(0,a.kt)("inlineCode",{parentName:"h3"},"Point:SetPosition()")),(0,a.kt)("p",null,"Used to set a new position for the point"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"parameters - ",(0,a.kt)("inlineCode",{parentName:"li"},"PositionX: number, PositionY: number")),(0,a.kt)("li",{parentName:"ul"},"returns - ",(0,a.kt)("inlineCode",{parentName:"li"},"nil"))),(0,a.kt)("hr",null),(0,a.kt)("h3",{id:"pointsetmaxforce"},(0,a.kt)("inlineCode",{parentName:"h3"},"Point:SetMaxForce()")),(0,a.kt)("p",null,"Determines the max force that can be applied to the Point."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"parameters - ",(0,a.kt)("inlineCode",{parentName:"li"},"maxForce: number")),(0,a.kt)("li",{parentName:"ul"},"returns - ",(0,a.kt)("inlineCode",{parentName:"li"},"nil"))),(0,a.kt)("hr",null),(0,a.kt)("h2",{id:"fetch-methods"},"Fetch Methods"),(0,a.kt)("h3",{id:"pointvelocity"},(0,a.kt)("inlineCode",{parentName:"h3"},"Point:Velocity()")),(0,a.kt)("p",null,"Returns the velocity of the Point."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"parameters - ",(0,a.kt)("inlineCode",{parentName:"li"},"none")),(0,a.kt)("li",{parentName:"ul"},"returns ",(0,a.kt)("inlineCode",{parentName:"li"},"velocity: Vector2"))),(0,a.kt)("h3",{id:"pointgetparent"},(0,a.kt)("inlineCode",{parentName:"h3"},"Point:GetParent()")),(0,a.kt)("p",null,"Returns the Parent (Constraint) of the Point if any."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"parameters - none"),(0,a.kt)("li",{parentName:"ul"},"return - parent: Constraint | nil")),(0,a.kt)("h3",{id:"pointgetnetforce"},(0,a.kt)("inlineCode",{parentName:"h3"},"Point:GetNetForce()")),(0,a.kt)("p",null,"Returns the net force acting on the point."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"parameters - none"),(0,a.kt)("li",{parentName:"ul"},"returns - ",(0,a.kt)("inlineCode",{parentName:"li"},"netForce: Vector2"))),(0,a.kt)("h2",{id:"properties"},"Properties"),(0,a.kt)("h3",null,"Position ",(0,a.kt)("code",null,"Vector2")," ",(0,a.kt)("code",null,(0,a.kt)("font",{color:"#ff5252"},"(must-have)"))),"The position of the point on screen.",(0,a.kt)("h3",{id:"visible-boolean"},"Visible ",(0,a.kt)("inlineCode",{parentName:"h3"},"boolean")),(0,a.kt)("p",null,"Whether or not the point is visible/being rendered on screen."),(0,a.kt)("h3",{id:"snap-boolean"},"Snap ",(0,a.kt)("inlineCode",{parentName:"h3"},"boolean")),(0,a.kt)("p",null,"Whether or not the point is anchored."),(0,a.kt)("h3",{id:"keepincanvas-boolean"},"KeepInCanvas ",(0,a.kt)("inlineCode",{parentName:"h3"},"boolean")),(0,a.kt)("p",null,"Whether or not the point will be able to go out of its confined canvas."),(0,a.kt)("h3",{id:"radius-number"},"Radius ",(0,a.kt)("inlineCode",{parentName:"h3"},"number")),(0,a.kt)("p",null,"The radius of the point."),(0,a.kt)("h3",{id:"color-number"},"Color ",(0,a.kt)("inlineCode",{parentName:"h3"},"number")),(0,a.kt)("p",null,"The BackgroundColor of the point's frame."))}u.isMDXComponent=!0}}]);